/**
 ****************************************************************************************************
 * @file        lwip_tcp_server.c
 * @version     V1.0
 * @date        2024-06-26
 * @brief       ÊûÑÂª∫tcpÊúçÂä°Âô®
 ****************************************************************************************************
 */
#include <stdint.h>
#include <stdio.h>
#include "lwip/pbuf.h"
#include "lwip/udp.h"
#include "lwip/tcp.h"
#include "lwip_tcp_server.h"
#include "lwip_comm.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "screen.h"
#include "los_event.h"
#include "los_task.h"
#include "SD.h"


#define LWIP_DEMO_PORT               8080   /*Êú¨Âú∞Á´ØÂè£Âè∑ */

 
/* ÂèëÈÄÅÊï∞ÊçÆÂÜÖÂÆπ */
char *g_lwip_command_sendbuf1 = "command1#";
char *g_lwip_command_sendbuf2 = "command2#";
char *g_lwip_command_sendbuf3 = "command3#";
char *g_lwip_command_sendbuf4 = "command4#";
/* TCP Server ÂÖ®Â±ÄÁä∂ÊÄÅÊ†áËÆ∞ÂèòÈáè
 * bit7:0ÔºåÊó†Êï∞ÊçÆÂèëÈÄÅÔºõ1ÊúâÊï∞ÊçÆÂèëÈÄÅ
 * bit6:0,Ê≤°Áî®Êî∂Âà∞Êï∞ÊçÆÔºõÊî∂Âà∞Êï∞ÊçÆ‰∫Ü
 * bit5:0,Ê≤°ÊúâÂÆ¢Êà∑Á´ØËøûÊé•‰∏ä
 * bit4~0:‰øùÁïô */
uint8_t g_lwip_send_flag;
static PServerData g_SevData;
/* tcpËøûÊé•Áä∂ÊÄÅÃ¨ */
enum tcp_server_states
{
    ES_TCPSERVER_NONE = 0,                  /*ÂàùÂßãÂåñ */
    ES_TCPSERVER_ACCEPTED,                  /* ËøûÊé•Áä∂ÊÄÅ */
    ES_TCPSERVER_CLOSING,                   /* ÂÖ≥Èó≠ËøûÊé•Áä∂ÊÄÅÃ¨ */
};

/* LWIPÂõûË∞ÉÂáΩÊï∞‰ΩøÁî®ÁªìÊûÑ‰Ωì */
struct tcp_server_struct
{
    uint8_t state;                          /* ÂΩìÂâçÁä∂ÊÄÅÃ¨ */
    struct tcp_pcb *pcb;                    /*ÊåáÂêëTCPÊéßÂà∂Âùó */
    struct pbuf *p;                         /*ÊåáÂêëtx/rx/pbuf */
};

static err_t lwip_tcp_server_accept(void *arg,struct tcp_pcb *newpcb,err_t err);
static err_t lwip_tcp_server_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err);
static void lwip_tcp_server_error(void *arg,err_t err);
static err_t lwip_tcp_server_usersent(struct tcp_pcb *tpcb,char *buf);
static err_t lwip_tcp_server_poll(void *arg, struct tcp_pcb *tpcb);
static err_t lwip_tcp_server_sent(void *arg, struct tcp_pcb *tpcb, u16_t len);
static void lwip_tcp_server_senddata(struct tcp_pcb *tpcb, struct tcp_server_struct *es);
static void lwip_tcp_server_connection_close(struct tcp_pcb *tpcb, struct tcp_server_struct *es);
static void lwip_tcp_server_remove_timewait(void);

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_run
* Âäü    ËÉΩÔºöÊûÑÂª∫tcpÊúçÂä°Âô®
* ÂèÇÊï∞ËØ¥ÊòéÔºöÊó†
* Ëøî Âõû ÂÄºÔºöÊó†
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
void lwip_run()
{
    err_t err;
    struct tcp_pcb *tcppcbnew;          
		struct tcp_pcb *tcppcbconn;         /* ÂÆö‰πâTCPÊúçÂä°Âô®ÊéßÂà∂Âùó */
    
    char *tbuf;
    uint8_t res = 0;

    tbuf = malloc(200);       /*Áî≥ËØ∑ÂÜÖÂ≠ò */

    if (tbuf == NULL)return ;        

    sprintf((char *)tbuf, "Server IP:%d.%d.%d.%d", g_lwipdev.ip[0], g_lwipdev.ip[1], g_lwipdev.ip[2], g_lwipdev.ip[3]); 
	g_SevData->IP = tbuf;
    sprintf((char *)tbuf, "Server Port:%d", LWIP_DEMO_PORT);                                                            
	g_SevData->PORT = tbuf;
    tcppcbnew = tcp_new();              /*ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑpcb */
	g_SevData->recvbuf = g_lwip_demo_recvbuf;
    if (tcppcbnew)                    
    {
        err = tcp_bind(tcppcbnew, IP_ADDR_ANY, LWIP_DEMO_PORT); /*Â∞ÜÊú¨Âú∞ip‰∏éÁ´ØÂè£Âè∑ÁªëÂÆö÷∑ */

        if (err == ERR_OK)              
        {
            tcppcbconn = tcp_listen(tcppcbnew);                 
            tcp_accept(tcppcbconn, lwip_tcp_server_accept);     
        }
        else
				{
					res = 1;
				}
					
    }
    else res = 1;
		
    while (res == 0)
    {
				/*ÊîπÊàêÁõëÊµãÂëΩ‰ª§‰∏ãÂèë*/
				int t=0;
				unsigned int uwEvent;
				uwEvent=LOS_EventRead(&Screen_EventGroup_CB,
													ETH_Command1_EVENT|ETH_Command2_EVENT|ETH_Command3_EVENT|ETH_Command4_EVENT,
													LOS_WAITMODE_OR|LOS_WAITMODE_CLR,
													10);
				if(ETH_Command1_EVENT == uwEvent)
				{
					lwip_tcp_server_usersent(tcppcbnew,g_lwip_command_sendbuf1);
					LOS_EventClear(&Screen_EventGroup_CB, ETH_Command1_EVENT);
					printf("command1#\r\n");
				}
				else if(ETH_Command2_EVENT == uwEvent)
				{
					lwip_tcp_server_usersent(tcppcbnew,g_lwip_command_sendbuf2);
					LOS_EventClear(&Screen_EventGroup_CB, ETH_Command1_EVENT);
				}
				else if(ETH_Command3_EVENT == uwEvent)
				{
					lwip_tcp_server_usersent(tcppcbnew,g_lwip_command_sendbuf3);
					LOS_EventClear(&Screen_EventGroup_CB, ETH_Command1_EVENT);
				}
				else if(ETH_Command4_EVENT == uwEvent)
				{
					lwip_tcp_server_usersent(tcppcbnew,g_lwip_command_sendbuf4);
					LOS_EventClear(&Screen_EventGroup_CB, ETH_Command1_EVENT);
				}
				if (g_lwip_send_flag & 1 << 6)                          /* ÊòØÂê¶Êî∂Âà∞Êï∞ÊçÆ */
				{
					SetTextValue(4,3,g_lwip_demo_recvbuf);
					printf("%s",g_lwip_demo_recvbuf);/* Â∞ÜÊï∞ÊçÆÂèëÁªô‰∏≤Âè£Â±èÊàñËÄÖ‰∏ä‰∫ë */
											
					 g_lwip_send_flag &= ~(1 << 6);                      /* Ê†áËÆ∞ */
				}
				lwip_periodic_handle();
				lwip_pkt_handle();
				LOS_TaskDelay(20);
				t++;

    }
}

void InitServerData(PServerData PtSev)
{
	PtSev = g_SevData;
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_accept
* Âäü    ËÉΩÔºöLWIP TCP_acceptÁöÑÂõûË∞ÉÂáΩÊï∞
* ÂèÇÊï∞ËØ¥ÊòéÔºöÊó†
* Ëøî Âõû ÂÄºÔºöÊó†
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
err_t lwip_tcp_server_accept(void *arg, struct tcp_pcb *newpcb, err_t err)
{
    err_t ret_err;
    struct tcp_server_struct *es;
    LWIP_UNUSED_ARG(arg);
    LWIP_UNUSED_ARG(err);
    tcp_setprio(newpcb, TCP_PRIO_MIN);                                  
    es = (struct tcp_server_struct *)mem_malloc(sizeof(struct tcp_server_struct)); 

    if (es != NULL)                                                 
    {
				printf("Connect TCP Client Success.\r\n");
				SetTextValue(4,10,"Connected");
				SetButtonValue(4,11,0);
        es->state = ES_TCPSERVER_ACCEPTED;                             
        es->pcb = newpcb;
        es->p = NULL;
        
        tcp_arg(newpcb, es);
        tcp_recv(newpcb, lwip_tcp_server_recv);                         
        tcp_err(newpcb, lwip_tcp_server_error);                        
        tcp_poll(newpcb, lwip_tcp_server_poll, 1);                      
        tcp_sent(newpcb, lwip_tcp_server_sent);                         

        g_lwip_send_flag |= 1 << 5;                                     
        g_lwipdev.remoteip[0] = newpcb->remote_ip.addr & 0xff;          /* IADDR4 */
        g_lwipdev.remoteip[1] = (newpcb->remote_ip.addr >> 8) & 0xff;   /* IADDR3 */
        g_lwipdev.remoteip[2] = (newpcb->remote_ip.addr >> 16) & 0xff;  /* IADDR2 */
        g_lwipdev.remoteip[3] = (newpcb->remote_ip.addr >> 24) & 0xff;  /* IADDR1 */
        ret_err = ERR_OK;
    }
    else
    {
				printf("Disconnect TCP Client.\r\n");
				SetTextValue(4,10,"Disconnected");
				SetButtonValue(4,11,0);
        ret_err = ERR_MEM;
    }

    return ret_err;
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_recv
* Âäü    ËÉΩÔºöLWIP TCP_recvÁöÑÂõûË∞ÉÂáΩÊï∞
* ÂèÇÊï∞ËØ¥ÊòéÔºöargÔºö‰º†ÂÖ•ÂèÇÊï∞
						tpcbÔºötcpÊéßÂà∂Âùó
						PÔºöÊï∞ÊçÆÂåÖÈ¶ñÂú∞ÂùÄ
* Ëøî Âõû ÂÄºÔºöerrÔºöÈîôËØØÁ†Å
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
err_t lwip_tcp_server_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
{
    err_t ret_err;
    uint32_t data_len = 0;
    struct pbuf *q;
    struct tcp_server_struct *es;
    LWIP_ASSERT("arg != NULL", arg != NULL);
    es = (struct tcp_server_struct *)arg;

	if (p == NULL)                                                          /*Êï∞ÊçÆ‰∏∫Á©∫ÂàôÂÖ≥Èó≠TCPËøûÊé• */
    {
        es->state = ES_TCPSERVER_CLOSING;         
        es->p = p;
        ret_err = ERR_OK;
    }
    else if (err != ERR_OK)                                                 /*Êï∞ÊçÆÈùûÁ©∫‰ΩÜÊòØÂá∫Áé∞ÊÑèÂ§ñÈîôËØØ */
    {
        if (p)pbuf_free(p);                                                 /*ÈáäÊîæpbuf */

        ret_err = err;
    }
    else if (es->state == ES_TCPSERVER_ACCEPTED)                            /* Â§Ñ‰∫éËøûÊé•Áä∂ÊÄÅ*/
    {
        if (p != NULL)                                                      /* ÂΩìÂ§Ñ‰∫éËøûÊé•Áä∂ÊÄÅÂπ∂Êé•ÂèóÂà∞Êï∞ÊçÆ‰∏ç‰∏∫Á©∫Êó∂ÊâìÂç∞ */
        {
					memset(g_lwip_demo_recvbuf, 0, LWIP_DEMO_RX_BUFSIZE);           /* Ê∏ÖÁ©∫Êé•Êî∂Âå∫ */

					for (q = p; q != NULL; q = q->next)                             /* ÈÅçÂéÜpbufÈìæË°® */
            {
                /* Âà§Êñ≠pbufÊï∞ÊçÆÊòØÂê¶Â§ß‰∫éLWIP_DEMO_RX_BUFSIZEÂ≠òÂÇ®ÊûÅÈôêÔºåÂ§ß‰∫éÂàôÂè™Êã∑Ë¥ùÂèØÂÆπÁ∫≥ÁöÑÊï∞ÊçÆÈáè */
                
                if (q->len > (LWIP_DEMO_RX_BUFSIZE - data_len)) memcpy(g_lwip_demo_recvbuf + data_len, q->payload, (LWIP_DEMO_RX_BUFSIZE - data_len)); /* øΩ±¥ ˝æ› */
                else memcpy(g_lwip_demo_recvbuf + data_len, q->payload, q->len);

                data_len += q->len;

                if (data_len > LWIP_DEMO_RX_BUFSIZE) break;              
            }

            g_lwip_send_flag |= 1 << 6;                                     /*ÂÖ≥Èó≠ÊúçÂä°Âô®Ê∏ÖÁ©∫ÈáäÊîæÂÜÖÂ≠ò*/
            g_lwipdev.remoteip[0] = tpcb->remote_ip.addr & 0xff;            /* IADDR4 */
            g_lwipdev.remoteip[1] = (tpcb->remote_ip.addr >> 8) & 0xff;     /* IADDR3 */
            g_lwipdev.remoteip[2] = (tpcb->remote_ip.addr >> 16) & 0xff;    /* IADDR2 */
            g_lwipdev.remoteip[3] = (tpcb->remote_ip.addr >> 24) & 0xff;    /* IADDR1 */
            tcp_recved(tpcb, p->tot_len);
            pbuf_free(p);                                                   
            ret_err = ERR_OK;
        }
    }
    else                                                                   
    {
        tcp_recved(tpcb, p->tot_len);                                       
        es->p = NULL;
        pbuf_free(p);                                                      
        ret_err = ERR_OK;
    }

    return ret_err;
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_error
* Âäü    ËÉΩÔºöLWIP TCP_errÁöÑÂõûË∞ÉÂáΩÊï∞
* ÂèÇÊï∞ËØ¥ÊòéÔºöargÔºö‰º†ÂÖ•ÂèÇÊï∞
			errÔºöÈîôËØØÁ†Å
* Ëøî Âõû ÂÄºÔºöÊó†
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
void lwip_tcp_server_error(void *arg, err_t err)
{
		SetTextValue(4,10,"Disconnected");
		SetButtonValue(4,11,1);
    LWIP_UNUSED_ARG(err);
    printf("tcp error:%x\r\n", (uint32_t)arg);
    if (arg != NULL)mem_free(arg); 
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_usersent
* Âäü    ËÉΩÔºöÊï∞ÊçÆÂèëÈÄÅ
* ÂèÇÊï∞ËØ¥ÊòéÔºötpcbÔºötcpÊéßÂà∂Âùó
						bufÔºöÂëΩ‰ª§‰∏ãÂèëbuf
* Ëøî Âõû ÂÄºÔºöerrÔºöÈîôËØØÁ†Å
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
err_t lwip_tcp_server_usersent(struct tcp_pcb *tpcb,char *buf)
{
    err_t ret_err;
    struct tcp_server_struct *es;
    es = tpcb->callback_arg;

    if (es != NULL)                                                       
    {
        es->p = pbuf_alloc(PBUF_TRANSPORT, strlen((char *)buf), PBUF_POOL); 
        pbuf_take(es->p, (char *)buf, strlen((char *)buf)); 
        lwip_tcp_server_senddata(tpcb, es);                                                 
        g_lwip_send_flag &= ~(1 << 7);                                                      

        if (es->p != NULL)pbuf_free(es->p);                                                

        ret_err = ERR_OK;
    }
    else
    {
//        tcp_abort(tpcb);                                                                    
        ret_err = ERR_ABRT;
    }

    return ret_err;
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_poll
* Âäü    ËÉΩÔºötcp_pollÁöÑÂõûË∞ÉÂáΩÊï∞
* ÂèÇÊï∞ËØ¥ÊòéÔºötpcbÔºötcpÊéßÂà∂Âùó
						argÔºö‰º†ÂÖ•ÂèÇÊï∞
* Ëøî Âõû ÂÄºÔºöerrÔºöÈîôËØØÁ†Å
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
err_t lwip_tcp_server_poll(void *arg, struct tcp_pcb *tpcb)
{
    err_t ret_err;
    struct tcp_server_struct *es;
    es = (struct tcp_server_struct *)arg;

    if (es->state == ES_TCPSERVER_CLOSING)			
    {
				SetTextValue(4,10,"Disconnected");
				SetButtonValue(4,11,1);
        lwip_tcp_server_connection_close(tpcb, es);    
    }

    ret_err = ERR_OK;
    return ret_err;
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_sent
* Âäü    ËÉΩÔºötcp_sentÁöÑÂõûË∞ÉÂáΩÊï∞
* ÂèÇÊï∞ËØ¥ÊòéÔºötpcbÔºötcpÊéßÂà∂Âùó
						argÔºö‰º†ÂÖ•ÂèÇÊï∞
* Ëøî Âõû ÂÄºÔºöerrÔºöÈîôËØØÁ†Å
* ËØ¥    ÊòéÔºö(ÂÆ¢Êà∑Á´ØÊé•Êî∂Âà∞ACK‰ø°Âè∑ÂêéÂèëÈÄÅÊï∞ÊçÆ)
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
err_t lwip_tcp_server_sent(void *arg, struct tcp_pcb *tpcb, u16_t len)
{
    struct tcp_server_struct *es;
    LWIP_UNUSED_ARG(len);
    es = (struct tcp_server_struct *) arg;

    if (es->p)lwip_tcp_server_senddata(tpcb, es);   

    return ERR_OK;
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_senddata
* Âäü    ËÉΩÔºöÂèëÈÄÅÊï∞ÊçÆ
* ÂèÇÊï∞ËØ¥ÊòéÔºötpcbÔºötcpÊéßÂà∂Âùó
						esÔºöLWIPÂõûË∞ÉÂáΩÊï∞‰ΩøÁî®ÁöÑÁªìÊûÑ‰Ωì
* Ëøî Âõû ÂÄºÔºöÊó†
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
void lwip_tcp_server_senddata(struct tcp_pcb *tpcb, struct tcp_server_struct *es)
{
    struct pbuf *ptr;
    uint16_t plen;
    err_t wr_err = ERR_OK;

    while ((wr_err == ERR_OK) && es->p && (es->p->len <= tcp_sndbuf(tpcb)))
    {
        ptr = es->p;
        wr_err = tcp_write(tpcb, ptr->payload, ptr->len, 1);    /*Â∞ÜË¶ÅÂèëÈÄÅÁöÑÊï∞ÊçÆÂä†ÂÖ•ÂèëÈÄÅÁºìÂÜ≤ÈòüÂàó‰∏≠*/

        if (wr_err == ERR_OK)
        {
            plen = ptr->len;
            es->p = ptr->next;                                  /*ÊåáÂêë‰∏ã‰∏Ä‰∏™pbuf */

            if (es->p)pbuf_ref(es->p);                          

            pbuf_free(ptr);
            tcp_recved(tpcb, plen);
        }
        else if (wr_err == ERR_MEM) es->p = ptr;
        tcp_output(tpcb);                                       /* ÂèëÈÄÅÁºìÂÜ≤ÈòüÂàó‰∏≠ÁöÑÊï∞ÊçÆ */
    }
}

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_connection_close
* Âäü    ËÉΩÔºöÂÖ≥Èó≠tcpËøûÊé•
* ÂèÇÊï∞ËØ¥ÊòéÔºötpcbÔºötcpÊéßÂà∂Âùó
						esÔºöLWIPÂõûË∞ÉÂáΩÊï∞‰ΩøÁî®ÁöÑÁªìÊûÑ‰Ωì
* Ëøî Âõû ÂÄºÔºöÊó†
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
void lwip_tcp_server_connection_close(struct tcp_pcb *tpcb, struct tcp_server_struct *es)
{
    tcp_close(tpcb);
    tcp_arg(tpcb, NULL);
    tcp_sent(tpcb, NULL);
    tcp_recv(tpcb, NULL);
    tcp_err(tpcb, NULL);
    tcp_poll(tpcb, NULL, 0);

    if (es)mem_free(es);
    g_lwip_send_flag &= ~(1 << 5);                  /* Ê†áËÆ∞ËøûÊé•Êñ≠ÂºÄ*/
}

extern void tcp_pcb_purge(struct tcp_pcb *pcb);     
extern struct tcp_pcb *tcp_active_pcbs;            
extern struct tcp_pcb *tcp_tw_pcbs;                 

/*******************************************************************************
* Âêç    Áß∞Ôºölwip_tcp_server_remove_timewait
* Âäü    ËÉΩÔºöÂº∫Âà∂Âà†Èô§TCP Server‰∏ªÂä®Êñ≠ÂºÄÊó∂ÁöÑtime wait
* ÂèÇÊï∞ËØ¥ÊòéÔºöÊó†
* Ëøî Âõû ÂÄºÔºöÊó†
* ËØ¥    ÊòéÔºöÊó†
* Ë∞ÉÁî®ÊñπÊ≥ïÔºöÂ§ñÈÉ®Ë∞ÉÁî®
*******************************************************************************/
void lwip_tcp_server_remove_timewait(void)
{
    struct tcp_pcb *pcb, *pcb2;
    uint8_t t = 0;

    while (tcp_active_pcbs != NULL && t < 200)
    {
        lwip_periodic_handle();                     
        t++;
        LOS_TaskDelay(10);                               
		}

    pcb = tcp_tw_pcbs;

    while (pcb != NULL)                             
    {
        tcp_pcb_purge(pcb);
        tcp_tw_pcbs = pcb->next;
        pcb2 = pcb;
        pcb = pcb->next;
        memp_free(MEMP_TCP_PCB, pcb2);
    }
}

